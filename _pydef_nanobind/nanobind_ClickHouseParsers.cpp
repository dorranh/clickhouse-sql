#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/ndarray.h>

#include "DummyLib.h"

namespace nb = nanobind;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_clickhouse_sql(nb::module_& m)
{
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:DummyLib.h>    ////////////////////

    { // <namespace DummyLib>
        nb::module_ pyNsDummyLib = m.def_submodule("dummy_lib", "namespace DummyLib");
        auto pyNsDummyLib_ClassDummyClass =
            nb::class_<DummyLib::DummyClass>
                (pyNsDummyLib, "DummyClass", "*\n * @brief A simple demonstration class for testing Python bindings\n *\n * This class provides basic functionality to test the nanobind + litgen\n * binding pipeline. It includes various data types and methods that\n * are commonly used in C++ applications.\n")
            .def(nb::init<>(),
                "*\n     * @brief Default constructor\n     *\n     * Creates a DummyClass with default name \"unnamed\" and value 0\n")
            .def(nb::init<const std::string &>(),
                nb::arg("name"),
                "*\n     * @brief Constructor with custom name\n     * @param name The name to assign to this instance\n     *\n     * Creates a DummyClass with the specified name and default value 0\n")
            .def("get_name",
                &DummyLib::DummyClass::getName, "*\n     * @brief Get the current name of this instance\n     * @return The name as a string\n")
            .def("set_name",
                &DummyLib::DummyClass::setName,
                nb::arg("name"),
                "*\n     * @brief Set the name of this instance\n     * @param name The new name to assign\n")
            .def("get_value",
                &DummyLib::DummyClass::getValue, "*\n     * @brief Get the current numeric value\n     * @return The current value as an integer\n")
            .def("set_value",
                &DummyLib::DummyClass::setValue,
                nb::arg("value"),
                "*\n     * @brief Set the numeric value\n     * @param value The new value to assign\n")
            .def("get_numbers",
                &DummyLib::DummyClass::getNumbers, "*\n     * @brief Get the list of numbers stored in this instance\n     * @return A vector containing all stored numbers\n")
            .def("add_number",
                &DummyLib::DummyClass::addNumber,
                nb::arg("num"),
                "*\n     * @brief Add a number to the internal list\n     * @param num The number to add to the list\n")
            ;


        auto pyNsDummyLib_ClassDummyStruct =
            nb::class_<DummyLib::DummyStruct>
                (pyNsDummyLib, "DummyStruct", "*\n * @brief A simple struct for testing struct bindings\n *\n * This struct demonstrates how to bind C++ structs with public members\n * to Python. All members are public and can be accessed directly.\n")
            .def_rw("name", &DummyLib::DummyStruct::name, "/< The name of this struct instance")
            .def_rw("value", &DummyLib::DummyStruct::value, "/< A numeric value")
            .def_rw("flag", &DummyLib::DummyStruct::flag, "/< A boolean flag")
            .def(nb::init<>(),
                "*\n     * @brief Default constructor\n     *\n     * Creates a DummyStruct with default values: name=\"default\", value=0, flag=False\n")
            .def(nb::init<const std::string &, int, bool>(),
                nb::arg("n"), nb::arg("v"), nb::arg("f"),
                "*\n     * @brief Constructor with custom values\n     * @param n The name to assign\n     * @param v The numeric value to assign\n     * @param f The boolean flag to assign\n")
            ;


        pyNsDummyLib.def("greet",
            DummyLib::greet,
            nb::arg("name"),
            "*\n * @brief Generate a greeting message\n * @param name The name to greet\n * @return A greeting string in the format \"Hello, {name}!\"\n *\n * This function demonstrates simple string manipulation and return values\n");

        pyNsDummyLib.def("add",
            DummyLib::add,
            nb::arg("a"), nb::arg("b"),
            "*\n * @brief Add two integers\n * @param a First integer\n * @param b Second integer\n * @return The sum of a and b\n *\n * Basic arithmetic function to test numeric parameter passing\n");

        pyNsDummyLib.def("multiply",
            DummyLib::multiply,
            nb::arg("a"), nb::arg("b"),
            "*\n * @brief Multiply two floating-point numbers\n * @param a First number\n * @param b Second number\n * @return The product of a and b\n *\n * Demonstrates floating-point arithmetic and different numeric types\n");

        pyNsDummyLib.def("create_range",
            DummyLib::createRange,
            nb::arg("start"), nb::arg("end"),
            "*\n * @brief Create a range of integers\n * @param start The starting value (inclusive)\n * @param end The ending value (inclusive)\n * @return A vector containing integers from start to end\n *\n * This function demonstrates returning containers and range-based logic\n");
    } // </namespace DummyLib>
    ////////////////////    </generated_from:DummyLib.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}